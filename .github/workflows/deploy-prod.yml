name: Deploy-Prod

on:
  workflow_dispatch:

concurrency:
  group: deploy-prod
  cancel-in-progress: true

jobs:
  tests:
    uses: ./.github/workflows/test-suite.yml
    with:
      ref: 'master'

  deploy:
    runs-on: ubuntu-latest
    needs: tests

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.18.0'

      - name: Install AWS CLI
        run: |
          sudo apt-get install -y python3-pip
          pip3 install awscliv2

      - name: Configure AWS Credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Install CDK
        run: npm install -g aws-cdk@latest

      - name: Install CDK Dependencies
        run: npm install
        working-directory: ./deployment

      - name: Copy secrets file
        run: cp secrets.yml.example secrets.yml
        working-directory: ./src/config
      
      - name: CDK Deploy
        run: cdk deploy SchengTrackProd --require-approval never
        working-directory: ./deployment

      - name: Resolve Ops Lambda Function
        id: ops_lambda
        run: |
          STACK_NAME="SchengTrackProd"
          OPS_FUNCTION_NAME=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query "Stacks[0].Outputs[?OutputKey=='OpsLambdaFunctionName'].OutputValue" --output text)
          if [ -z "$OPS_FUNCTION_NAME" ] || [ "$OPS_FUNCTION_NAME" = "None" ]; then
            echo "Failed to resolve Ops Lambda function name"
            exit 1
          fi
          echo "ops_function_name=$OPS_FUNCTION_NAME" >> $GITHUB_OUTPUT

      - name: Run database migrations
        env:
          OPS_FUNCTION_NAME: ${{ steps.ops_lambda.outputs.ops_function_name }}
        run: |
          set -euo pipefail
          invoke_ops_lambda() {
            local payload="$1"
            local description="$2"
            echo "Invoking ${description} via ops Lambda..."
            aws lambda invoke \
              --function-name "$OPS_FUNCTION_NAME" \
              --payload "$payload" \
              --cli-binary-format raw-in-base64-out \
              /tmp/ops-response.json >/tmp/ops-invoke.log
            cat /tmp/ops-response.json
            jq -e '.body | fromjson | select(.success == true)' /tmp/ops-response.json >/dev/null
            echo "✓ ${description} completed"
          }

          invoke_ops_lambda '{"command":"fix_people_migration"}' "Fix people migration metadata"
          invoke_ops_lambda '{"command":"unlock_and_migrate"}' "Database migrations"

      - name: Update countries data
        env:
          OPS_FUNCTION_NAME: ${{ steps.ops_lambda.outputs.ops_function_name }}
        run: |
          set -euo pipefail
          aws lambda invoke \
            --function-name "$OPS_FUNCTION_NAME" \
            --payload '{"command":"update_countries"}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/update-countries.json >/tmp/update-countries.log
          cat /tmp/update-countries.json
          jq -e '.body | fromjson | select(.success == true)' /tmp/update-countries.json >/dev/null
          echo "✓ Countries data updated successfully"

      - name: Clean up guest users
        env:
          OPS_FUNCTION_NAME: ${{ steps.ops_lambda.outputs.ops_function_name }}
        run: |
          set -euo pipefail
          aws lambda invoke \
            --function-name "$OPS_FUNCTION_NAME" \
            --payload '{"command":"guest_cleanup","params":{"max_batches":5}}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/guest-cleanup.json >/tmp/guest-cleanup.log
          cat /tmp/guest-cleanup.json
          jq -e '.body | fromjson | select(.success == true)' /tmp/guest-cleanup.json >/dev/null
          stats=$(jq -r '.body | fromjson | .stats // empty' /tmp/guest-cleanup.json)
          if [ -n "$stats" ]; then
            deleted=$(echo "$stats" | jq -r '.deleted // 0')
            batches=$(echo "$stats" | jq -r '.batches // 0')
            remaining=$(echo "$stats" | jq -r '.remaining // 0')
            echo "Deleted: $deleted users in $batches batches"
            echo "Remaining: $remaining"
          fi

  cacheInvalidate:
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install AWS CLI
        run: |
          sudo apt-get install -y python3-pip
          pip3 install awscliv2

      - name: Configure AWS Credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region ${{ secrets.AWS_DEFAULT_REGION }}
      
      - name: Set deployment timestamp
        run: |
          echo "Setting deployment timestamp in Parameter Store..."
          current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          aws ssm put-parameter \
            --name "/schengen/deployment-timestamp" \
            --value "$current_time" \
            --type String \
            --overwrite
          echo "✓ Deployment timestamp set to: $current_time"
      
      
      - name: Perform CloudFront Invalidation
        id: cloudfront_invalidation
        run: |
          invalidation_id=$(aws cloudfront create-invalidation --distribution-id E1KF4KLAR0V084 --paths '/*' --query Invalidation.Id --output text)
          echo "invalidationId=${invalidation_id}" >> $GITHUB_OUTPUT
      
      - name: Wait for CloudFront Invalidation
        run: aws cloudfront wait invalidation-completed --distribution-id E1KF4KLAR0V084 --id "${{ steps.cloudfront_invalidation.outputs.invalidationId }}"

      - name: Recache main urls
        run: ./recache.sh urls-prod.txt
        working-directory: ./deployment/scripts

